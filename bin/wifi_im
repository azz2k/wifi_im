#!/usr/bin/env python

# ros
import rospy
import tf
import actionlib
from nav_msgs.msg import OccupancyGrid
from nav_msgs.srv import GetMap
from geometry_msgs.msg import PoseStamped
from geometry_msgs.msg import PoseWithCovarianceStamped
from move_base_msgs.msg import *
# other stuff
import numpy as np
from matplotlib import pyplot as plt
import Queue
import random
import math

class WifiIM:
  def __init__(self):
    rospy.init_node("wifi_im", anonymous=True)
    # misc variables
    self.tflistener = tf.TransformListener()
    self.pose = PoseStamped()
    # msg stuff
    self.msg_queue = Queue.Queue()
    rospy.Subscriber("/amcl_pose", PoseWithCovarianceStamped, self.callback_pos)
    # get map
    print "waiting for map"
    rospy.wait_for_service("/static_map")
    get_map_service  = rospy.ServiceProxy("/static_map", GetMap)
    get_map_response = get_map_service()
    print "got map"
    self.ogrid = np.array(get_map_response.map.data, dtype=np.int8)
    self.ogrid = self.ogrid.reshape((get_map_response.map.info.height, get_map_response.map.info.width))
    self.resolution = get_map_response.map.info.resolution
    self.origin = get_map_response.map.info.origin
    del get_map_service
    del get_map_response
    grid_goals = self.generate_grid(0.5, 0.5)
    plt.imshow(self.ogrid, cmap=plt.cm.binary, origin="lower", vmin=-1, vmax=1)
    for goal in grid_goals:
      plt.plot(goal[0], goal[1], "b.")
    plt.gca().set_xlim((0, 3200))
    plt.gca().set_ylim((0, 4500))
    plt.show()
    return
    # main loop
    self.run()
  def run(self):
    r = rospy.Rate(5)
    plt.ion()
    plt.gcf().canvas._tkcanvas.master.geometry("1000x1200")
    while not rospy.is_shutdown():
      print rospy.Time.now()
      while not self.msg_queue.empty():
        data = self.msg_queue.get()
        if data[0] == "amcl_pose":
          pose = PoseStamped()
          pose.header = data[1].header
          pose.pose = data[1].pose.pose
          self.pose = pose
      plt.clf()
      plt.imshow(self.ogrid, cmap=plt.cm.binary, origin="lower", vmin=-1, vmax=1)
      plt.plot((self.pose.pose.position.x - self.origin.position.x)/self.resolution, (self.pose.pose.position.y - self.origin.position.y)/self.resolution, "r*")
      cbar = plt.colorbar()
      plt.gca().set_xlim((0, 3200))
      plt.gca().set_ylim((0, 4500))
      plt.draw()
      for i in range(100):
        # yaw is zero in -x direction for euler angles in /map frame
        yaw = random.uniform(-math.pi, math.pi)
        newx = (self.pose.pose.position.x - self.origin.position.x)/self.resolution - 150 * math.cos(yaw)
        newy = (self.pose.pose.position.y - self.origin.position.y)/self.resolution + 150 * math.sin(yaw)
        # look at the average for clearer results around walls and complicated objects
        window = int(0.5/self.resolution)/2
        if np.mean(self.ogrid[newy-window:newy+window, newx-window:newx+window]) == 0:
          print newx, newy
          self.goto(newx, newy, yaw)
          break
      r.sleep()
  def goto(self, x, y, yaw):
    print "goto", x * self.resolution + self.origin.position.x, y * self.resolution + self.origin.position.y, yaw
    client = actionlib.SimpleActionClient("/move_base", MoveBaseAction)
    client.wait_for_server()
    goal = MoveBaseGoal()
    goal.target_pose.header.frame_id = "/map"
    goal.target_pose.header.stamp = rospy.Time.now()
    goal.target_pose.pose.position.x = x * self.resolution + self.origin.position.x
    goal.target_pose.pose.position.y = y * self.resolution + self.origin.position.y
    goal.target_pose.pose.position.z = self.pose.pose.position.z
    quaternion = tf.transformations.quaternion_from_euler(yaw, 0.0, 0.0)
    goal.target_pose.pose.orientation.w = quaternion[0]
    goal.target_pose.pose.orientation.x = quaternion[1]
    goal.target_pose.pose.orientation.y = quaternion[2]
    goal.target_pose.pose.orientation.z = quaternion[3]
    client.send_goal(goal)
    client.wait_for_result()
  def generate_grid(self, dx, dy):
    grid_goals = []
    window = int(0.5/self.resolution)/2
    for x in np.arange(window, self.ogrid.shape[1]-window, dx/self.resolution):
      for y in np.arange(window, self.ogrid.shape[0]-window, dy/self.resolution):
        if np.mean(self.ogrid[y-window:y+window, x-window:x+window]) == 0:
          grid_goals.append([x, y])
    return grid_goals
  def callback_pos(self, data):
    print "amcl_pose", [data.pose.pose.position.x, data.pose.pose.position.y, tf.transformations.euler_from_quaternion([data.pose.pose.orientation.w, data.pose.pose.orientation.x, data.pose.pose.orientation.y, data.pose.pose.orientation.z])[0]]
    self.msg_queue.put(["amcl_pose", data])

if __name__ == "__main__":
  try:
    wifi_im = WifiIM()
  except rospy.ROSInterruptException:
    pass
