#!/usr/bin/env python

# ros
import rospy
import tf
import actionlib
from nav_msgs.msg import OccupancyGrid
from nav_msgs.srv import GetMap
from geometry_msgs.msg import PoseStamped
from geometry_msgs.msg import PoseWithCovarianceStamped
from move_base_msgs.msg import *
from wifi_sensor.msg import RssiMulti
# other stuff
import numpy as np
from matplotlib import pyplot as plt
import Queue
import random
import math
from sklearn.neighbors import RadiusNeighborsRegressor
from sklearn.neighbors import KNeighborsRegressor

class WifiIM:
  def __init__(self):
    rospy.init_node("wifi_im", anonymous=True)
    # parameter
    target_mac = rospy.get_param("~target_mac", "")
    print target_mac
    # misc variables
    self.tflistener = tf.TransformListener()
    self.pose = PoseStamped()
    self.rssi_log = []
    # msg stuff
    self.msg_queue = Queue.Queue()
    rospy.Subscriber("/amcl_pose", PoseWithCovarianceStamped, self.callback_pos)
    rospy.Subscriber("/rssi", RssiMulti, self.callback_rssi)
    # get map
    print "waiting for map"
    rospy.wait_for_service("/static_map")
    get_map_service  = rospy.ServiceProxy("/static_map", GetMap)
    get_map_response = get_map_service()
    print "got map"
    self.ogrid = np.array(get_map_response.map.data, dtype=np.int8)
    self.ogrid = self.ogrid.reshape((get_map_response.map.info.height, get_map_response.map.info.width))
    self.resolution = get_map_response.map.info.resolution
    self.origin = get_map_response.map.info.origin
    del get_map_service
    del get_map_response
    # main loop
    self.run_find_ap(target_mac)
  def run_find_ap(self, target_mac):
    # parameters
    search_radius = 1.0
    # models
    model = RadiusNeighborsRegressor(radius=2.0, weights="distance")
    model_bak = KNeighborsRegressor(n_neighbors=10, weights="distance")
    # dummy fit
    model.fit([[0.0, 0.0]], [0.0])
    model_bak.fit([[0.0, 0.0]], [0.0])
    # data containers
    rssi_log = []
    pose_log = []
    xyr = []
    while not rospy.is_shutdown():
      print rospy.Time.now()
      # deal with messages
      while not self.msg_queue.empty():
        data = self.msg_queue.get()
        if data[0] == "amcl_pose":
          pose_log.append([data[1].header.stamp, data[1].pose.pose])
        if data[0] == "rssi":
          for rssi in data[1].data:
            if rssi.their_mac_addr == target_mac:
              rssi_log.append([data[1].header.stamp, np.mean([mes for mes in rssi.rssi if mes < 0])])
      # maybe sorting?
      # check model predictions
      prediction = 0.0
      try:
        prediction = model.predict([pose_log[-1][1].position.x, pose_log[-1][1].position.y]) 
      except:
        prediction = model_bak.predict([pose_log[-1][1].position.x, pose_log[-1][1].position.y]) 
      if abs(prediction - rssi_log[-1][1]) > 3.0:
        xy = [[pose[0].to_time(), pose[1].position.x, pose[1].position.x] for pose in pose_log]
        r = [[rssi[0].to_time(), rssi[1]] for rssi in rssi_log]
        xyr = self.interpolate(xy, r)
        model.fit([[x, y] for t, x, y, r in xyr], [r for t, x, y, r in xyr])
        model_bak.fit([[x, y] for t, x, y, r in xyr], [r for t, x, y, r in xyr])
      # find new search direction
      candidates = [[pose_log[-1][1].position.x + search_radius*math.cos(alpha), pose_log[-1][1].position.y + search_radius*math.sin(alpha)] for alpha in np.linspace(0.0, 2*math.pi, 36)]
      candidates = [pos for pos in candidates if self.test_point_real(pos[0], pos[1], 0.25)]
      predictions = []
      for candidate in candidates:
        prediction = 0.0
        try:
          prediction = model.predict(candidate)
        except:
          prediction = model_bak.predict(candidate)
        predictions.append([candidate, prediction])
      predictions = sorted(predictions, key=lambda x:x[1])
      # and goto (blocking)
      goal = predictions[-1][0]
      yaw = math.pi-math.atan2(goal[1] - pose_log[-1][1].position.y, goal[0] - pose_log[-1][1].position.x)
      #self.goto_real(goal[0], goal[1], yaw)
  def interpolate(self, xy, rssi):
    xy = sorted(xy, key=lambda x:x[0])
    r = sorted(rssi, key=lambda x:x[0])
    xyr = []
    r_i = 0
    xy_i = 0
    while(xy[0][0] > r[r_i][0]):
      r_i = r_i + 1
    for r_i in range(r_i, len(r)):
      if xy_i+1 >= len(xy):
        break
      while(xy[xy_i+1][0] <= r[r_i][0]):
        xy_i = xy_i + 1
        if xy_i+1 >= len(xy):
          break
      if xy_i+1 >= len(xy):
        break
      x = (xy[xy_i+1][1] - xy[xy_i][1])/(xy[xy_i+1][0] - xy[xy_i][0]) * (r[r_i][0] - xy[xy_i][0]) + xy[xy_i][1]
      y = (xy[xy_i+1][2] - xy[xy_i][2])/(xy[xy_i+1][0] - xy[xy_i][0]) * (r[r_i][0] - xy[xy_i][0]) + xy[xy_i][2]
      xyr.append([r[r_i][0], x, y, r[r_i][1]])
    return xyr
  def run_random_directions(self):
    r = rospy.Rate(5)
    plt.ion()
    plt.gcf().canvas._tkcanvas.master.geometry("1000x1200")
    while not rospy.is_shutdown():
      print rospy.Time.now()
      while not self.msg_queue.empty():
        data = self.msg_queue.get()
        if data[0] == "amcl_pose":
          pose = PoseStamped()
          pose.header = data[1].header
          pose.pose = data[1].pose.pose
          self.pose = pose
      plt.clf()
      plt.imshow(self.ogrid, cmap=plt.cm.binary, origin="lower", vmin=-1, vmax=1)
      plt.plot((self.pose.pose.position.x - self.origin.position.x)/self.resolution, (self.pose.pose.position.y - self.origin.position.y)/self.resolution, "r*")
      cbar = plt.colorbar()
      plt.gca().set_xlim((0, 3200))
      plt.gca().set_ylim((0, 4500))
      plt.draw()
      for i in range(100):
        # yaw is zero in -x direction for euler angles in /map frame
        yaw = random.uniform(-math.pi, math.pi)
        newx = (self.pose.pose.position.x - self.origin.position.x)/self.resolution - 150 * math.cos(yaw)
        newy = (self.pose.pose.position.y - self.origin.position.y)/self.resolution + 150 * math.sin(yaw)
        # look at the average for clearer results around walls and complicated objects
        window = int(0.5/self.resolution)/2
        if np.mean(self.ogrid[newy-window:newy+window, newx-window:newx+window]) == 0:
          print newx, newy
          self.goto_map(newx, newy, yaw)
          break
      r.sleep()
  def run_sample_grid(self):
    grid_goals = self.generate_grid(1.0, 1.0)
    plt.ion()
    plt.gcf().canvas._tkcanvas.master.geometry("1000x1200")
    plt.imshow(self.ogrid, cmap=plt.cm.binary, origin="lower", vmin=-1, vmax=1)
    cbar = plt.colorbar()
    for goal in grid_goals:
      plt.plot(goal[0], goal[1], "g.")
    plt.gca().set_xlim((0, 3200))
    plt.gca().set_ylim((0, 4500))
    for goal in grid_goals:
      print rospy.Time.now()
      if rospy.is_shutdown():
        break
      while not self.msg_queue.empty():
        data = self.msg_queue.get()
        if data[0] == "amcl_pose":
          pose = PoseStamped()
          pose.header = data[1].header
          pose.pose = data[1].pose.pose
          self.pose = pose
          plt.plot((self.pose.pose.position.x - self.origin.position.x)/self.resolution, (self.pose.pose.position.y - self.origin.position.y)/self.resolution, "r,")
        elif data[0] == "rssi":
          rssi_dict = {}
          for rssi in data[1].data:
            if rssi.their_mac_addr not in rssi_dict.keys():
              rssi_dict[rssi.their_mac_addr] = []
            rssi_dict[rssi.their_mac_addr].extend(rssi.rssi)
          self.rssi_log.append([data[1].header.stamp, rssi_dict])
      plt.plot((self.pose.pose.position.x - self.origin.position.x)/self.resolution, (self.pose.pose.position.y - self.origin.position.y)/self.resolution, "b.")
      plt.draw()
      currx = (self.pose.pose.position.x - self.origin.position.x)/self.resolution
      curry = (self.pose.pose.position.y - self.origin.position.y)/self.resolution
      yaw = math.pi-math.atan2(goal[1] - curry, goal[0] - currx)
      self.goto_map(goal[0], goal[1], yaw)
  def goto_real(self, x, y, yaw):
    self.goto_map((x-self.origin.position.x)/self.resolution, (y-self.origin.position.y)/self.resolution, yaw)
  def goto_map(self, x, y, yaw):
    print "goto", x * self.resolution + self.origin.position.x, y * self.resolution + self.origin.position.y, yaw
    client = actionlib.SimpleActionClient("/move_base", MoveBaseAction)
    client.wait_for_server()
    goal = MoveBaseGoal()
    goal.target_pose.header.frame_id = "/map"
    goal.target_pose.header.stamp = rospy.Time.now()
    goal.target_pose.pose.position.x = x * self.resolution + self.origin.position.x
    goal.target_pose.pose.position.y = y * self.resolution + self.origin.position.y
    goal.target_pose.pose.position.z = self.pose.pose.position.z
    quaternion = tf.transformations.quaternion_from_euler(yaw, 0.0, 0.0)
    goal.target_pose.pose.orientation.w = quaternion[0]
    goal.target_pose.pose.orientation.x = quaternion[1]
    goal.target_pose.pose.orientation.y = quaternion[2]
    goal.target_pose.pose.orientation.z = quaternion[3]
    client.send_goal(goal)
    client.wait_for_result()
  def generate_grid(self, dx, dy):
    grid_goals = []
    window = int(0.5/self.resolution)/2
    for y in np.arange(window, self.ogrid.shape[0]-window, dy/self.resolution):
      for x in np.arange(window, self.ogrid.shape[1]-window, dx/self.resolution):
        if test_point_map(x, y, window):
          grid_goals.append([x, y])
    return grid_goals
  def test_point_real(self, x, y, window):
    return self.test_point_map((x-self.origin.position.x)/self.resolution, (y-self.origin.position.y)/self.resolution, int(window/self.resolution))
  def test_point_map(self, x, y, window):
    if np.mean(self.ogrid[y-window:y+window, x-window:x+window]) == 0:
      return True
    else:
      return False
  def callback_pos(self, data):
    print "amcl_pose", [data.pose.pose.position.x, data.pose.pose.position.y, tf.transformations.euler_from_quaternion([data.pose.pose.orientation.w, data.pose.pose.orientation.x, data.pose.pose.orientation.y, data.pose.pose.orientation.z])[0]]
    self.msg_queue.put(["amcl_pose", data])
  def callback_rssi(self, data):
    self.msg_queue.put(["rssi", data])

if __name__ == "__main__":
  try:
    wifi_im = WifiIM()
  except rospy.ROSInterruptException:
    pass
