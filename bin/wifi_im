#!/usr/bin/env python

# ros
import rospy
import tf
import actionlib
from nav_msgs.msg import OccupancyGrid
from nav_msgs.srv import GetMap
from geometry_msgs.msg import Pose
from geometry_msgs.msg import PoseStamped
from geometry_msgs.msg import PoseWithCovarianceStamped
from tf2_msgs.msg import TFMessage
from move_base_msgs.msg import *
from wifi_sensor.msg import RssiMulti
# other stuff
import numpy as np
from matplotlib import pyplot as plt
import Queue
import random
import math
from sklearn.svm import SVR
from sklearn.neighbors import KNeighborsRegressor
from sklearn.neighbors import RadiusNeighborsRegressor
from sklearn.linear_model import Ridge
try:
  from sklearn.preprocessing import StandardScaler
except:
  from sklearn.preprocessing import Scaler as StandardScaler

class WifiIM:
  def __init__(self):
    rospy.init_node("wifi_im", anonymous=True)
    # parameter
    target_mac = rospy.get_param("~target_mac", "")
    # misc variables
    self.pose = Pose()
    # data containers
    self.rssi_log = []
    self.pose_log = []
    self.xyr = []
    # msg stuff
    self.msg_queue = Queue.Queue()
    rospy.Subscriber("/amcl_pose", PoseWithCovarianceStamped, self.callback_pos)
    rospy.Subscriber("/tf", TFMessage, self.callback_tf)
    rospy.Subscriber("/rssi", RssiMulti, self.callback_rssi)
    # get map
    print "waiting for map"
    rospy.wait_for_service("/static_map")
    get_map_service  = rospy.ServiceProxy("/static_map", GetMap)
    get_map_response = get_map_service()
    print "got map"
    self.ogrid = np.array(get_map_response.map.data, dtype=np.int8)
    self.ogrid = self.ogrid.reshape((get_map_response.map.info.height, get_map_response.map.info.width))
    self.resolution = get_map_response.map.info.resolution
    self.origin = get_map_response.map.info.origin
    del get_map_service
    del get_map_response
    # main loop
    self.run_find_ap(target_mac)
  def run_find_ap(self, target_mac):
    # model
    model = Ridge()
    selector = RadiusNeighborsRegressor(radius=3.0, weights="distance")
    # plotting
    plt.ion()
    plt.gcf().canvas._tkcanvas.master.geometry("1000x1200")
    while not rospy.is_shutdown():
      print rospy.Time.now()
      # deal with messages
      self.process_msgs()
      print "self.rssi_log", len(rssi_log)
      print "self.pose_log", len(pose_log)
      # maybe sorting?
      # check model predictions
      prediction = model.predict([self.pose.pose.position.x, self.pose.pose.position.y]) 
      if abs(prediction - self.rssi_log[-1][1]) > 5.0 or len(self.xyr) == 0:
        local_radius = 3.0
        # sample data
        candidates = []
        for x in np.linspace(self.pose.pose.position.x-local_radius, self.pose.pose.position.x+local_radius, 30):
          for y in np.linspace(self.pose.pose.position.y-local_radius, self.pose.pose.position.y+local_radius, 30):
            candidates.append([x, y])
        candidates = [candidate for candidate in candidates if math.hypot(candidate[0] - self.pose.pose.position.x, candidate[1] - self.pose.pose.position.y) <= local_radius]
        candidates = [candidate for candidate in candidates if self.test_point_real(candidate[0], candidate[1], 0.25)]
        search_wps = [random.choice(candidates) for i in range(3)]
        for i in range(len(search_wps))
          print "sample wp", i, ":", search_wps[i]
          if i == 0:
            yaw = math.pi-math.atan2(search_wps[i][1] - self.pose.pose.position.y, search_wps[i][0] - self.pose.pose.position.x)
          else:
            yaw = math.pi-math.atan2(search_wps[i][1] - search_wps[i-1][1], search_wps[i][0] - search_wps[i-1][0])
          self.goto_real(search_wps[i], yaw)
        # go back to starting point
        yaw = math.pi-math.atan2(self.pose.pose.position.y - search_wps[i][1], self.pose.pose.position.x - search_wps[i][0])
        self.goto_real([self.pose.pose.position.x, self.pose.pose.position.y], yaw)
        # process new messages
        self.process_msgs()
        # process data
        print "fitting local model"
        xy = [[pose[0].to_time(), pose[1].position.x, pose[1].position.y] for pose in self.pose_log]
        r = [[rssi[0].to_time(), rssi[1]] for rssi in self.rssi_log]
        self.xyr = self.interpolate(xy, r)
        # find relevant data and fit data
        selector.fit([[x, y] for t, x, y, r in self.xyr], [r for t, x, y, r in xyr])
        dist, ind = selector.radius_neighbors([self.pose.pose.position.x, self.pose.pose.position.y], radius=local_radius)
        model.fit([[self.xyr[idx][1], xyr[idx][2]] for idx in ind[0]], [xyr[idx][3] for idx in ind[0]])
        print "self.xyr", len(xyr), "and", len(ind[0]), "used"
      # find new search direction
      search_step = 0.5
      candidates = []
      for alpha in np.linspace(0, 2.0*math.pi, 36):
        candidates.append([x+seach_step*math.cos(alpha), y+seach_step*math.sin(alpha)])
      candidates = [candidate for candidate in candidates if self.test_point_real(candidate[0], candidate[1], 0.25)]
      print "candidates", len(candidates)
      predictions = []
      for candidate in candidates:
        prediction = model.predict(candidate)
        predictions.append([candidate, prediction])
      predictions = sorted(predictions, key=lambda x:x[1])
      # and goto (blocking)
      goal = predictions[-1][0]
      yaw = math.pi-math.atan2(goal[1] - self.pose_log[-1][1].position.y, goal[0] - pose_log[-1][1].position.x)
      # generate visualization for model
      xx = np.linspace(-10, 0, 20)
      yy = np.linspace(-14, 20, 70)
      rssi_plot = np.zeros((len(xx), len(yy)))
      for i in range(len(xx)):
        for j in range(len(yy)):
          rssi_plot[i, j] = model.predict([[xx[i], yy[j]]])
      # plotting
      plt.clf()
      plt.suptitle(target_mac)
      plt.subplot(121)
      plt.title("model")
      plt.pcolormesh(xx, yy, rssi_plot.T, cmap=plt.get_cmap("gnuplot2"), vmin=-100, vmax=0)
      plt.plot([x for t, x, y, r in self.xyr], [y for t, x, y, r in xyr], "g-")
      plt.plot(goal[0], goal[1], "r*")
      plt.gca().set_xlim((min(xx), max(xx)))
      plt.gca().set_xlabel("x [m]")
      plt.gca().set_ylim((min(yy), max(yy)))
      plt.gca().set_ylabel("y [m]")
      cbar = plt.colorbar()
      cbar.set_label("mean rssi [dB]")
      plt.subplot(122)
      plt.title("hexbin")
      plt.hexbin([x for t, x, y, r in self.xyr], [y for t, x, y, r in xyr], [r for t, x, y, r in xyr], gridsize=20, cmap=plt.get_cmap("gnuplot2"), vmin=-100, vmax=0, extent=(min(xx), max(xx), min(yy), max(yy)))
      plt.plot([x for t, x, y, r in self.xyr], [y for t, x, y, r in xyr], "g-")
      plt.plot(goal[0], goal[1], "r*")
      plt.gca().set_xlim((min(xx), max(xx)))
      plt.gca().set_xlabel("x [m]")
      plt.gca().set_ylim((min(yy), max(yy)))
      plt.gca().set_ylabel("y [m]")
      cbar = plt.colorbar()
      cbar.set_label("mean rssi [dB]")
      plt.draw()
      # moving
      self.goto_real(goal[0], goal[1], yaw)
  def process_msgs(self):
    while not self.msg_queue.empty():
      data = self.msg_queue.get()
      if data[0] == "amcl_pose":
        self.pose_log.append([data[1].header.stamp, data[1].pose.pose])
        pose = PoseStamped()
        pose.header = data[1].header
        pose.pose = data[1].pose.pose
        self.pose = pose
      if data[0] == "rssi":
        for rssi in data[1].data:
          if rssi.their_mac_addr == target_mac:
            if len([mes for mes in rssi.rssi if mes < 0]) > 0:
              self.rssi_log.append([data[1].header.stamp, np.mean([mes for mes in rssi.rssi if mes < 0])])
  def interpolate(self, xy, rssi):
    xy = sorted(xy, key=lambda x:x[0])
    r = sorted(rssi, key=lambda x:x[0])
    xyr = []
    r_i = 0
    xy_i = 0
    while(xy[0][0] > r[r_i][0]):
      r_i = r_i + 1
    for r_i in range(r_i, len(r)):
      if xy_i+1 >= len(xy):
        break
      while(xy[xy_i+1][0] <= r[r_i][0]):
        xy_i = xy_i + 1
        if xy_i+1 >= len(xy):
          break
      if xy_i+1 >= len(xy):
        break
      x = (xy[xy_i+1][1] - xy[xy_i][1])/(xy[xy_i+1][0] - xy[xy_i][0]) * (r[r_i][0] - xy[xy_i][0]) + xy[xy_i][1]
      y = (xy[xy_i+1][2] - xy[xy_i][2])/(xy[xy_i+1][0] - xy[xy_i][0]) * (r[r_i][0] - xy[xy_i][0]) + xy[xy_i][2]
      xyr.append([r[r_i][0], x, y, r[r_i][1]])
    return xyr
  def goto_real(self, x, y, yaw):
    print "goto", x, y, yaw
    client = actionlib.SimpleActionClient("/move_base", MoveBaseAction)
    client.wait_for_server()
    goal = MoveBaseGoal()
    goal.target_pose.header.frame_id = "/map"
    goal.target_pose.header.stamp = rospy.Time.now()
    goal.target_pose.pose.position.x = x
    goal.target_pose.pose.position.y = y
    goal.target_pose.pose.position.z = self.pose.pose.position.z
    quaternion = tf.transformations.quaternion_from_euler(yaw, 0.0, 0.0)
    goal.target_pose.pose.orientation.w = quaternion[0]
    goal.target_pose.pose.orientation.x = quaternion[1]
    goal.target_pose.pose.orientation.y = quaternion[2]
    goal.target_pose.pose.orientation.z = quaternion[3]
    client.send_goal(goal)
    client.wait_for_result()
  def goto_map(self, x, y, yaw):
    print "goto", x * self.resolution + self.origin.position.x, y * self.resolution + self.origin.position.y, yaw
    client = actionlib.SimpleActionClient("/move_base", MoveBaseAction)
    client.wait_for_server()
    goal = MoveBaseGoal()
    goal.target_pose.header.frame_id = "/map"
    goal.target_pose.header.stamp = rospy.Time.now()
    goal.target_pose.pose.position.x = x * self.resolution + self.origin.position.x
    goal.target_pose.pose.position.y = y * self.resolution + self.origin.position.y
    goal.target_pose.pose.position.z = self.pose.pose.position.z
    quaternion = tf.transformations.quaternion_from_euler(yaw, 0.0, 0.0)
    goal.target_pose.pose.orientation.w = quaternion[0]
    goal.target_pose.pose.orientation.x = quaternion[1]
    goal.target_pose.pose.orientation.y = quaternion[2]
    goal.target_pose.pose.orientation.z = quaternion[3]
    client.send_goal(goal)
    client.wait_for_result()
  def generate_grid(self, dx, dy):
    grid_goals = []
    window = int(0.5/self.resolution)/2
    for y in np.arange(window, self.ogrid.shape[0]-window, dy/self.resolution):
      for x in np.arange(window, self.ogrid.shape[1]-window, dx/self.resolution):
        if test_point_map(x, y, window):
          grid_goals.append([x, y])
    return grid_goals
  def test_point_real(self, x, y, window):
    return self.test_point_map((x-self.origin.position.x)/self.resolution, (y-self.origin.position.y)/self.resolution, int(window/self.resolution))
  def test_point_map(self, x, y, window):
    if np.mean(self.ogrid[y-window:y+window, x-window:x+window]) == 0:
      return True
    else:
      return False
  def callback_pos(self, data):
#    print "amcl_pose", [data.pose.pose.position.x, data.pose.pose.position.y, tf.transformations.euler_from_quaternion([data.pose.pose.orientation.w, data.pose.pose.orientation.x, data.pose.pose.orientation.y, data.pose.pose.orientation.z])[0]]
    self.msg_queue.put(["amcl_pose", data])
  def callback_tf(self, data):
    for msg in data.transforms:
      if msg.child_frame_id == "odom":
        self.msg_queue.put(["tf", msg])
  def callback_rssi(self, data):
    self.msg_queue.put(["rssi", data])

if __name__ == "__main__":
  try:
    wifi_im = WifiIM()
  except rospy.ROSInterruptException:
    pass
