#!/usr/bin/env python

# ros
import rospy
import tf
import actionlib
from nav_msgs.msg import OccupancyGrid
from nav_msgs.srv import GetMap
from geometry_msgs.msg import Pose
from geometry_msgs.msg import PoseStamped
from geometry_msgs.msg import PoseWithCovarianceStamped
from tf2_msgs.msg import TFMessage
from move_base_msgs.msg import *
from wifi_sensor.msg import RssiMulti
# other stuff
import numpy as np
from matplotlib import pyplot as plt
import Queue
import random
import math
from sklearn.svm import SVR
from sklearn.neighbors import KNeighborsRegressor
from sklearn.neighbors import RadiusNeighborsRegressor
from sklearn.linear_model import Ridge
try:
  from sklearn.preprocessing import StandardScaler
except:
  from sklearn.preprocessing import Scaler as StandardScaler

class WifiIM:
  def __init__(self):
    rospy.init_node("wifi_im", anonymous=True)
    # parameter
    target_mac = rospy.get_param("~target_mac", "")
    print target_mac
    # misc variables
    self.tflistener = tf.TransformListener()
    self.pose = Pose()
    self.rssi_log = []
    # msg stuff
    self.msg_queue = Queue.Queue()
    rospy.Subscriber("/amcl_pose", PoseWithCovarianceStamped, self.callback_pos)
    rospy.Subscriber("/tf", TFMessage, self.callback_tf)
    rospy.Subscriber("/rssi", RssiMulti, self.callback_rssi)
    # get map
    print "waiting for map"
    rospy.wait_for_service("/static_map")
    get_map_service  = rospy.ServiceProxy("/static_map", GetMap)
    get_map_response = get_map_service()
    print "got map"
    self.ogrid = np.array(get_map_response.map.data, dtype=np.int8)
    self.ogrid = self.ogrid.reshape((get_map_response.map.info.height, get_map_response.map.info.width))
    self.resolution = get_map_response.map.info.resolution
    self.origin = get_map_response.map.info.origin
    del get_map_service
    del get_map_response
    # main loop
    self.run_find_ap(target_mac)
  def run_find_ap(self, target_mac):
    # model
    model = SVR(C=1e-1)
    selector = RadiusNeighborsRegressor(radius=6.0, weights="distance")
    # data containers
    rssi_log = []
    pose_log = []
    xyr = []
    # plotting
    plt.ion()
    plt.gcf().canvas._tkcanvas.master.geometry("1000x1200")
    while not rospy.is_shutdown():
      print rospy.Time.now()
      # deal with messages
      while not self.msg_queue.empty():
        data = self.msg_queue.get()
        if data[0] == "amcl_pose":
          pose_log.append([data[1].header.stamp, data[1].pose.pose])
          pose = PoseStamped()
          pose.header = data[1].header
          pose.pose = data[1].pose.pose
          self.pose = pose
        if data[0] == "rssi":
          for rssi in data[1].data:
            if rssi.their_mac_addr == target_mac:
              if len([mes for mes in rssi.rssi if mes < 0]) > 0:
                rssi_log.append([data[1].header.stamp, np.mean([mes for mes in rssi.rssi if mes < 0])])
      print "rssi_log", len(rssi_log)
      print "pose_log", len(pose_log)
      # maybe sorting?
      # check model predictions
#        prediction = model.predict([pose_log[-1][1].position.x, pose_log[-1][1].position.y]) 
#      if abs(prediction - rssi_log[-1][1]) > 3.0 or True:
      xy = [[pose[0].to_time(), pose[1].position.x, pose[1].position.y] for pose in pose_log]
      r = [[rssi[0].to_time(), rssi[1]] for rssi in rssi_log]
      xyr = self.interpolate(xy, r)
      print "xyr", len(xyr)
      selector.fit([[x, y] for t, x, y, r in xyr], [r for t, x, y, r in xyr])
      dist, ind = selector.radius_neighbors([self.pose.pose.position.x, self.pose.pose.position.y], radius=6.0)
      xy_scaler = StandardScaler().fit([[xyr[idx][1], xyr[idx][2]] for idx in ind[0]])
      r_scaler = StandardScaler().fit([xyr[idx][3] for idx in ind[0]])
      model.fit(xy_scaler.transform([[xyr[idx][1], xyr[idx][2]] for idx in ind[0]]), r_scaler.transform([xyr[idx][3] for idx in ind[0]]))
      # find new search direction
      candidates = []
      for x in np.linspace(-10, 0, 20):
        for y in np.linspace(-14, 20, 70):
          candidates.append([x+random.uniform(-0.25, 0.25), y+random.uniform(-0.25, 0.25)])
      candidates = [pos for pos in candidates if self.test_point_real(pos[0], pos[1], 0.25)]
      candidates = [pos for pos in candidates if len(selector.radius_neighbors(pos, radius=0.5)[1][0]) == 0]
      print "candidates", len(candidates)
      predictions = []
      for candidate in candidates:
        prediction = r_scaler.inverse_transform(model.predict(xy_scaler.transform(candidate)))
        predictions.append([candidate, prediction])
      predictions = sorted(predictions, key=lambda x:x[1])
      # and goto (blocking)
      goal = predictions[-1][0]
      yaw = math.pi-math.atan2(goal[1] - pose_log[-1][1].position.y, goal[0] - pose_log[-1][1].position.x)
      # generate visualization for model
      xx = np.linspace(-10, 0, 20)
      yy = np.linspace(-14, 20, 70)
      rssi_plot = np.zeros((len(xx), len(yy)))
      for i in range(len(xx)):
        for j in range(len(yy)):
          rssi_plot[i, j] = r_scaler.inverse_transform(model.predict(xy_scaler.transform([[xx[i], yy[j]]])))
      # plotting
      plt.clf()
      plt.suptitle(target_mac+" @ "+str(len(xyr))+" samples")
      plt.subplot(121)
      plt.title("model")
      plt.pcolormesh(xx, yy, rssi_plot.T, cmap=plt.get_cmap("gnuplot2"), vmin=-100, vmax=0)
      plt.plot([x for t, x, y, r in xyr], [y for t, x, y, r in xyr], "g-")
      plt.plot(goal[0], goal[1], "r*")
      plt.gca().set_xlim((min(xx), max(xx)))
      plt.gca().set_xlabel("x [m]")
      plt.gca().set_ylim((min(yy), max(yy)))
      plt.gca().set_ylabel("y [m]")
      cbar = plt.colorbar()
      cbar.set_label("mean rssi [dB]")
      plt.subplot(122)
      plt.title("hexbin")
      plt.hexbin([x for t, x, y, r in xyr], [y for t, x, y, r in xyr], [r for t, x, y, r in xyr], gridsize=20, cmap=plt.get_cmap("gnuplot2"), vmin=-100, vmax=0, extent=(min(xx), max(xx), min(yy), max(yy)))
      plt.plot([x for t, x, y, r in xyr], [y for t, x, y, r in xyr], "g-")
      plt.plot(goal[0], goal[1], "r*")
      plt.gca().set_xlim((min(xx), max(xx)))
      plt.gca().set_xlabel("x [m]")
      plt.gca().set_ylim((min(yy), max(yy)))
      plt.gca().set_ylabel("y [m]")
      cbar = plt.colorbar()
      cbar.set_label("mean rssi [dB]")
      plt.draw()
      # moving
      self.goto_real(goal[0], goal[1], yaw)
  def interpolate(self, xy, rssi):
    xy = sorted(xy, key=lambda x:x[0])
    r = sorted(rssi, key=lambda x:x[0])
    xyr = []
    r_i = 0
    xy_i = 0
    while(xy[0][0] > r[r_i][0]):
      r_i = r_i + 1
    for r_i in range(r_i, len(r)):
      if xy_i+1 >= len(xy):
        break
      while(xy[xy_i+1][0] <= r[r_i][0]):
        xy_i = xy_i + 1
        if xy_i+1 >= len(xy):
          break
      if xy_i+1 >= len(xy):
        break
      x = (xy[xy_i+1][1] - xy[xy_i][1])/(xy[xy_i+1][0] - xy[xy_i][0]) * (r[r_i][0] - xy[xy_i][0]) + xy[xy_i][1]
      y = (xy[xy_i+1][2] - xy[xy_i][2])/(xy[xy_i+1][0] - xy[xy_i][0]) * (r[r_i][0] - xy[xy_i][0]) + xy[xy_i][2]
      xyr.append([r[r_i][0], x, y, r[r_i][1]])
    return xyr
  def run_random_directions(self):
    r = rospy.Rate(5)
    plt.ion()
    plt.gcf().canvas._tkcanvas.master.geometry("1000x1200")
    while not rospy.is_shutdown():
      print rospy.Time.now()
      while not self.msg_queue.empty():
        data = self.msg_queue.get()
        if data[0] == "amcl_pose":
          pose = PoseStamped()
          pose.header = data[1].header
          pose.pose = data[1].pose.pose
          self.pose = pose
      plt.clf()
      plt.imshow(self.ogrid, cmap=plt.cm.binary, origin="lower", vmin=-1, vmax=1)
      plt.plot((self.pose.pose.position.x - self.origin.position.x)/self.resolution, (self.pose.pose.position.y - self.origin.position.y)/self.resolution, "r*")
      cbar = plt.colorbar()
      plt.gca().set_xlim((0, 3200))
      plt.gca().set_ylim((0, 4500))
      plt.draw()
      for i in range(100):
        # yaw is zero in -x direction for euler angles in /map frame
        yaw = random.uniform(-math.pi, math.pi)
        newx = (self.pose.pose.position.x - self.origin.position.x)/self.resolution - 150 * math.cos(yaw)
        newy = (self.pose.pose.position.y - self.origin.position.y)/self.resolution + 150 * math.sin(yaw)
        # look at the average for clearer results around walls and complicated objects
        window = int(0.5/self.resolution)/2
        if np.mean(self.ogrid[newy-window:newy+window, newx-window:newx+window]) == 0:
          print newx, newy
          self.goto_map(newx, newy, yaw)
          break
      r.sleep()
  def run_sample_grid(self):
    grid_goals = self.generate_grid(1.0, 1.0)
    plt.ion()
    plt.gcf().canvas._tkcanvas.master.geometry("1000x1200")
    plt.imshow(self.ogrid, cmap=plt.cm.binary, origin="lower", vmin=-1, vmax=1)
    cbar = plt.colorbar()
    for goal in grid_goals:
      plt.plot(goal[0], goal[1], "g.")
    plt.gca().set_xlim((0, 3200))
    plt.gca().set_ylim((0, 4500))
    for goal in grid_goals:
      print rospy.Time.now()
      if rospy.is_shutdown():
        break
      while not self.msg_queue.empty():
        data = self.msg_queue.get()
        if data[0] == "amcl_pose":
          pose = PoseStamped()
          pose.header = data[1].header
          pose.pose = data[1].pose.pose
          self.pose = pose
          plt.plot((self.pose.pose.position.x - self.origin.position.x)/self.resolution, (self.pose.pose.position.y - self.origin.position.y)/self.resolution, "r,")
        elif data[0] == "rssi":
          rssi_dict = {}
          for rssi in data[1].data:
            if rssi.their_mac_addr not in rssi_dict.keys():
              rssi_dict[rssi.their_mac_addr] = []
            rssi_dict[rssi.their_mac_addr].extend(rssi.rssi)
          self.rssi_log.append([data[1].header.stamp, rssi_dict])
      plt.plot((self.pose.pose.position.x - self.origin.position.x)/self.resolution, (self.pose.pose.position.y - self.origin.position.y)/self.resolution, "b.")
      plt.draw()
      currx = (self.pose.pose.position.x - self.origin.position.x)/self.resolution
      curry = (self.pose.pose.position.y - self.origin.position.y)/self.resolution
      yaw = math.pi-math.atan2(goal[1] - curry, goal[0] - currx)
      self.goto_map(goal[0], goal[1], yaw)
  def goto_real(self, x, y, yaw):
    print "goto", x, y, yaw
    client = actionlib.SimpleActionClient("/move_base", MoveBaseAction)
    client.wait_for_server()
    goal = MoveBaseGoal()
    goal.target_pose.header.frame_id = "/map"
    goal.target_pose.header.stamp = rospy.Time.now()
    goal.target_pose.pose.position.x = x
    goal.target_pose.pose.position.y = y
    goal.target_pose.pose.position.z = self.pose.pose.position.z
    quaternion = tf.transformations.quaternion_from_euler(yaw, 0.0, 0.0)
    goal.target_pose.pose.orientation.w = quaternion[0]
    goal.target_pose.pose.orientation.x = quaternion[1]
    goal.target_pose.pose.orientation.y = quaternion[2]
    goal.target_pose.pose.orientation.z = quaternion[3]
    client.send_goal(goal)
    client.wait_for_result()
  def goto_map(self, x, y, yaw):
    print "goto", x * self.resolution + self.origin.position.x, y * self.resolution + self.origin.position.y, yaw
    client = actionlib.SimpleActionClient("/move_base", MoveBaseAction)
    client.wait_for_server()
    goal = MoveBaseGoal()
    goal.target_pose.header.frame_id = "/map"
    goal.target_pose.header.stamp = rospy.Time.now()
    goal.target_pose.pose.position.x = x * self.resolution + self.origin.position.x
    goal.target_pose.pose.position.y = y * self.resolution + self.origin.position.y
    goal.target_pose.pose.position.z = self.pose.pose.position.z
    quaternion = tf.transformations.quaternion_from_euler(yaw, 0.0, 0.0)
    goal.target_pose.pose.orientation.w = quaternion[0]
    goal.target_pose.pose.orientation.x = quaternion[1]
    goal.target_pose.pose.orientation.y = quaternion[2]
    goal.target_pose.pose.orientation.z = quaternion[3]
    client.send_goal(goal)
    client.wait_for_result()
  def generate_grid(self, dx, dy):
    grid_goals = []
    window = int(0.5/self.resolution)/2
    for y in np.arange(window, self.ogrid.shape[0]-window, dy/self.resolution):
      for x in np.arange(window, self.ogrid.shape[1]-window, dx/self.resolution):
        if test_point_map(x, y, window):
          grid_goals.append([x, y])
    return grid_goals
  def test_point_real(self, x, y, window):
    return self.test_point_map((x-self.origin.position.x)/self.resolution, (y-self.origin.position.y)/self.resolution, int(window/self.resolution))
  def test_point_map(self, x, y, window):
    if np.mean(self.ogrid[y-window:y+window, x-window:x+window]) == 0:
      return True
    else:
      return False
  def callback_pos(self, data):
#    print "amcl_pose", [data.pose.pose.position.x, data.pose.pose.position.y, tf.transformations.euler_from_quaternion([data.pose.pose.orientation.w, data.pose.pose.orientation.x, data.pose.pose.orientation.y, data.pose.pose.orientation.z])[0]]
    self.msg_queue.put(["amcl_pose", data])
  def callback_tf(self, data):
    for msg in data.transforms:
      if msg.child_frame_id == "odom":
        self.msg_queue.put(["tf", msg])
  def callback_rssi(self, data):
    self.msg_queue.put(["rssi", data])

if __name__ == "__main__":
  try:
    wifi_im = WifiIM()
  except rospy.ROSInterruptException:
    pass
